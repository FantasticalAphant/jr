#!/bin/bash

# Simplified `javac` and `java`

# TODO - Show usage information
#      - Take in flags/options
#      - put into functions (modularize + refactor) + add main function, etc.
#      - custom flags (-k to keep the jvm file or -r to remove)
#      - some source files are non-intuitively not compiled if there are errors in some of them
#      - add something to properly run junit tests - similar to what is done in class (-t flag or something)
#      -
#      -

# Print to stderr
echoerr() { echo "$@" 1>&2; }

# ${args[0]} is the name of the first argument instead of the command itself
args=("$@") # store all of the arguments in an array for later use
files=() # all arguments that are not flags/options
# go through each argument and remove it if it starts with '-'

# Add argument to $files array if first character is not '-' (flag)
# There probably is a much simpler way to do this
for i in "${args[@]}"; do
    if [[ ${i:0:1} != "-" ]]; then
        files+=("$i")
    fi
done

k_flag=false # keep the compiled files if true
h_flag=false # use of help flag - do not exit with error
t_flag=false

# Print usage information
print_usage() {
    printf "Usage: jr [options] <source files>\n"
    if $h_flag; then
        exit 0
    fi
    exit 1 # exit with error; might have to remove if used for help (or pass an argument to decide)
}

# should every argument be checked or is one enough?
# get name of the package
package_name=$(find . -maxdepth 1 -iname '*.java' -exec grep '^package' {} + | cut -d' ' -f2 | head -n1 | sed 's/;//')

# what if `javac` was previously passed; should `jr` remove those previously compiled files?
# Print usage if there are not arguments passed with the command and there is no package
if [[ -z $args ]] && [[ -z $package_name ]]; then
    print_usage
fi
#(https://stackoverflow.com/questions/7069682/how-to-get-arguments-with-flags-in-bash9)
#(https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash)
# Get possible options/flags
while getopts 'kht' flag; do
    case "${flag}" in
        k) k_flag=true # do not remove the compiled file if this is the case
           ;;
        h) h_flag=true
           print_usage
           ;;
        t) t_flag=true
           ;;
        *) print_usage
           ;;
    esac
done

main_file="" # get the source file containing the main method
for file in $(find . -maxdepth 1 -iname '*.java'); do # iterate over all java source files in current directory (allows nesting)
    # above might be redundant (just change $file to *.java)
    if [[ -n $(grep 'public static void main' $file) ]]; then
        main_file=$file
    fi
done

# e.g. turns "./test.java" into "test"
main_file=$(echo $main_file | cut -d'.' -f2 | sed 's:^/::') # use : instead of / since it involves a path

# Remove compiled files after running the program
remove_compiled_files() {
    if $k_flag; then # keep the files if the 'k' flag is passed
        return
    fi

    if [[ $1 == 'file' ]]; then
        rm "${files[0]%.*}.class" # remove the compiled file
    fi
    if [[ $1 == 'directory' ]]; then
        rm -r $package_name # remove the directory with .class files
    fi
}

# TODO - rather than completely removing errors, pass them to another function for later use
#      - check if the file passed with jr is actually in the directory before running
#      - check what happens when a file that takes input is cancelled (^C) mid-run
# can the javac in the branches be replaced with javac -d . "$1" ?
# redirect error messages - can this be simplified?
compile_files() {
    if [[ -n $package_name ]]; then
        # simply below if possible
        stderr="$(javac -d . *.java 2>&1 > /dev/null)"
        if [[ $stderr =~ "Usage" ]]; then # check if there is a usage error instead of source code error
            # below works but is there a way to speed it up?
            echo "$stderr" | sed -z --expression='s/javac/jr/; s:<:[:; s:>:]:' # quote $stderr to preserve spacing
            exit 1
        else
            javac -d . *.java
        fi
        java "$package_name.$main_file" 2> /dev/null
        remove_compiled_files directory 2> /dev/null
    else
        stderr="$(javac "${files[0]}" 2>&1 > /dev/null)"
        if [[ $stderr =~ "Usage" ]]; then
            echo "$stderr" | sed -z --expression='s/javac/jr/; s:<:[:; s:>:]:' # change to match help
            exit 1;
        else
            javac "${files[0]}"
        fi
        java "${files[0]%.*}" "${files[@]:1}" 2> /dev/null # remove the extension and copy the arguments passed
        remove_compiled_files file 2> /dev/null
    fi
}

test_files() {
    # testing format
    # javac -d . -cp ./junit-platform-console-standalone-1.5.0.jar *.java
    # java -jar ./junit-platform-console-standalone-1.5.0.jar -cp . --scan-class-path

    # https://stackoverflow.com/questions/369145/how-to-assign-a-glob-expression-to-a-variable-in-a-bash-script
    jarfile=(junit-platform-console-standalone*.jar) # use array to enable globbing in variable

    if [[ ! -e $(pwd)/JUnitTests.java ]] && [[ ! -f "$jarfile" ]]; then
        echoerr JUnitTests.java does not exist
        echoerr JUnit executable JAR does not exist
        exit 1
    fi

    if [[ ! -e $(pwd)/JUnitTests.java ]]; then # built-in way to check if file exists
        echoerr JUnitTests.java does not exist # print error that unit test file does not exist
        exit 1
    fi

    # https://stackoverflow.com/questions/226703/how-do-i-prompt-for-yes-no-cancel-input-in-a-linux-shell-script for more info
    # link for the executable - https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/1.7.0/junit-platform-console-standalone-1.7.0.jar
    if [[ ! -f "$jarfile" ]]; then
        downloaded_jar=false
        while true; do
            read -p "Do you want to download the Junit exectable jar? " yn # get user input
            case $yn in
                [Yy]* ) $(wget https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/1.7.0/junit-platform-console-standalone-1.7.0.jar);
                    downloaded_jar=true
                    break
                    ;;
                [Nn]* ) break;;
                * ) echo "Enter y or n"
            esac
        done
        if ! $downloaded_jar; then
            echoerr JUnit executable JAR does not exist
            exit 1
        fi
    fi

    jarname=$(find . -iname "junit-platform-console-standalone*.jar") # search again if downloaded

    # check if jarname is non-empty
    javac -d . -cp $jarname *.java
    java -jar $jarname -cp . --scan-class-path | less -r # pipe result with color into pager

    # TODO - should the compiled directory be removed?
    rm -r $package_name
}

if $t_flag; then
    test_files
else
    compile_files
fi
